AutoGenerateDocumentation(script_filename) 
{
  ; Read this script and build a list of shortcut keys
	Sleep, 1000     ; Give VS Code time to save the file before we start
	shortcut_details := []
	shortcut_array_keys := []
	
	line_num = 1
	Loop
	{
    FileReadLine, line, %script_filename%, %A_Index%
    if ErrorLevel
      break
		; When search for lines in this file, have to explicitly exclude the next line
		If (RegExMatch(line, ".*;?.*::.*;.*[\|].*[\|]") And InStr(line, "RegExMatch") == 0)
		{
			;MsgBox, 4, , Line #%A_Index% MATCHES: %line%. Continue?
    	;IfMsgBox, No
      ;  break
			current_shortcut_details := {array_key: "", raw_text: "", shortcut_keys: "", group_name: "", is_ahk: "", comments: ""}

			; Parse out shortcut keys, the group name, and the comments
			; TODO: Exclude commented code: If line starts with ; and is_ahk then is commented code and skip it
			RegExMatch(line, "[;]?(.*)`:`:.*\;(.*?)\|(.*)\|(.*)", info)
			shortcut_keys_all = %info1%
			group_name = %info2%
			is_ahk = %info3%
			comments = %info4%

			; For sorting, want keys to look like this for nice sorting purposes, keeping all varieties of
			; shortcut keys for a single letter together
			;   Windows|j|#^j|JIRA
			;   Windows|j|#j|JIRA
			shortcut_keys_stripped := RegExReplace(shortcut_keys_all, "[#^+!]")
			array_key = %group_name%|%shortcut_keys_stripped%|%shortcut_keys_all%|%line_num%
			current_shortcut_details.array_key := array_key
			shortcut_array_keys.Push(array_key)

      ; Save the details of this shortcut key
			current_shortcut_details.raw_text := line
			current_shortcut_details.shortcut_keys := shortcut_keys_all
			current_shortcut_details.group_name := group_name
			current_shortcut_details.is_ahk := is_ahk
			current_shortcut_details.comments := comments
			shortcut_details.Push(current_shortcut_details)

			current_shortcut_details := ""  ; Release the object
			line_num++
		}
	}

  shortcut_array_keys := sortArray(shortcut_array_keys)

	; Build the output. Use shortcut_array_keys to get shortcut keys in the desired order.
	output := ""
	last_group := ""
	for index, element in shortcut_array_keys
	{
		details_index := StrSplit(element, "|")[4]
    details_object := shortcut_details[details_index]

		shortcut_keys := details_object.shortcut_keys
		group_name := details_object.group_name
		comments := details_object.comments

		padded_shortcut_keys := SubStr(shortcut_keys . "               ", 1, 15)
		padded_group_name := group_name
		If (details_object.is_ahk)
		  padded_group_name = %padded_group_name% (AHK)
	  padded_group_name := SubStr(padded_group_name . "                   ", 1, 19)
		
		If (last_group != "" And last_group != group_name)
		  output = %output%;`n
 		output = %output%; %padded_shortcut_keys% %padded_group_name% %comments%`n

		last_group := group_name
	}
	FileDelete, C:\Temp\Out.txt
	FileAppend, %output%, C:\Temp\Out.txt

  ; Backup our script
	source_filename = %script_filename%
	FormatTime, CurrentDateTime,, yyyy-MM-ddThh-mm-ss
	target_filename = %source_filename%.%CurrentDateTime%.ahk
  FileCopy, %source_filename%, %target_filename%

  ; Replace the "Shortcuts" documentation with our newly generated documentation
	FileRead, my_script, %script_filename%
	title_dashes := Replicate("-", 30)
	end_of_comments_dashes := Replicate("=", 120)
	new_output := "; Shortcuts - Auto-Generated`r`n; " . title_dashes . "`r`n" . output . ";" . end_of_comments_dashes
  ;test := RegExMatch(my_script, "s); Shortcuts Auto-Generated`r`n; -----+`r`n;")
  ;msgbox test is %test%
	my_script := RegExReplace(my_script, "s); Shortcuts - Auto-Generated`r`n; -----+`r`n;..*?;=====+", new_output)
	FileDelete, %source_filename%
	FileAppend, %my_script%, %source_filename%
	;Sleep, 1000

	MsgBox, Done regenerating shortcut documentation.
	Return
}

Replicate( Str, Count ) { ; By SKAN / CD: 01-July-2017 | goo.gl/U84K7J
  Return StrReplace( Format( "{:0" Count "}", "" ), 0, Str )
}

sortArray(arr) {
; Code from https://autohotkey.com/board/topic/93570-sortarray/
	if	!IsObject(arr)
		return	0
	new :=	[]
	For each, item in arr
		list .=	item "`n"
	list :=	Trim(list,"`n")
	Sort, list, %options%
	Loop, parse, list, `n, `r
		new.Insert(A_LoopField)
	Return new
}