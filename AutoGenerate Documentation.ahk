;---------------------------------------------------------------------------------------------------------------------
; Auto generate documentation for AHK
; 
; In my main .ahk file is documentation describing what various hotkeys do what. This is a combination of Windows
; hotkeys that I use, as well as all the hotkeys defined in that script. This documentation is between the "Hotkeys"
; header and the end of the comments.
;
; The documentation is AUTOMATICALLY generated by this code every time I save the .ahk file in Visual Studio Code.
; Conceptually, the steps are:
;   - Parse out all of the hotkeys from the .ahk file. This includes the commented-out Windows hotkeys that I have
;     listed at the end of the file, so that they get included in the documentation.
;   - Build an array with a "sorting key" for each hotkey, that when sorted, puts the hotkeys in the order I want them
;   - Build an array with the new description for each hotkey, putting the array in my desired order
;   - Build the new script by replacing the existing documentation in the .ahk script with the new documentation
;   - Make a backup before overwriting the original .ahk file
;---------------------------------------------------------------------------------------------------------------------
AutoGenerateDocumentation(script_filename) 
{
  Sleep, 1000     ; Give VS Code time to save the file before we start
	
	hotkey_details := ParseOutHotkeys(script_filename)
	sorting_keys := BuildArrayKeysForSorting(hotkey_details)
	new_hotkey_descriptions := BuildNewHotkeyDescriptions(sorting_keys, hotkey_details)

	FileRead, old_script, %script_filename%
	new_script := BuildNewScript(old_script, new_hotkey_descriptions)

	If (new_script != old_script)
	{
	  BackupScript(script_filename)

		FileDelete, %script_filename%
		FileAppend, %new_script%, %script_filename%

		MsgBox, Done regenerating shortcut documentation.
	}

	Return
}


;---------------------------------------------------------------------------------------------------------------------
; 
;---------------------------------------------------------------------------------------------------------------------
ParseOutHotkeys(script_filename) 
{
	hotkey_details := []
	
	Loop
	{
    FileReadLine, line, %script_filename%, %A_Index%
    if ErrorLevel
      break

		; When search for lines in this file, have to explicitly exclude the next line, because it gets included in the
		; regex
		If (RegExMatch(line, ".*;?.*::.*;.*[\|].*[\|]") And InStr(line, "RegExMatch") == 0)
		{
			;MsgBox, 4, , Line #%A_Index% MATCHES: %line%. Continue?
    	;IfMsgBox, No
      ;  break
			current_hotkey_details := {array_key: "", raw_text: "", shortcut_keys: "", group_name: "", is_ahk: "", comments: ""}

			; Parse out details. Note that the "extra" assignment to variables trims leading and trailing spaces.
			; TODO: Exclude commented code: If line starts with ; and is_ahk then is commented code and skip it
			RegExMatch(line, "[;]?(.*)`:`:.*\;(.*?)\|(.*)\|(.*)", info)
			shortcut_keys = %info1%
			group_name = %info2%
			is_ahk = %info3%
			comments = %info4%

			current_hotkey_details.shortcut_keys := shortcut_keys
			current_hotkey_details.group_name := group_name
			current_hotkey_details.is_ahk := is_ahk
			current_hotkey_details.comments := comments
			hotkey_details.Push(current_hotkey_details)

			current_hotkey_details := ""  ; Release the object
		}
	}

	Return hotkey_details
}


;---------------------------------------------------------------------------------------------------------------------
; 
;---------------------------------------------------------------------------------------------------------------------
BuildArrayKeysForSorting(hotkey_details) 
{
	sorting_keys := []
	
	for index, element in hotkey_details
	{
		; For sorting, we want keys to look like this for nice sorting purposes, keeping all varieties of shortcut keys
		; for a single letter together
		;   Windows|j|#^j|JIRA
		;   Windows|j|#j|JIRA
		shortcut_keys_all := element.shortcut_keys
		shortcut_keys_stripped := RegExReplace(shortcut_keys_all, "[#^+!]")
		group_name := element.group_name
		array_key = %group_name%|%shortcut_keys_stripped%|%shortcut_keys_all%|%index%
		;MsgBox, 4, , Line #%index% KEY = %array_key%. Continue?
		;IfMsgBox, No
		;  break
		sorting_keys.Push(array_key)
	}

	Return sorting_keys
}


;---------------------------------------------------------------------------------------------------------------------
; 
;---------------------------------------------------------------------------------------------------------------------
BuildNewHotkeyDescriptions(sorting_keys, hotkey_details) {
	; Sort the array of keys to be in the order we want
  sorting_keys := SortArray(sorting_keys)

	; Build the output. Use shortcut_array_keys to get shortcut keys in the desired order.
	output := ""
	last_group := ""
	for index, element in sorting_keys
	{
		details_index := StrSplit(element, "|")[4]
    details_object := hotkey_details[details_index]

		shortcut_keys := details_object.shortcut_keys
		group_name := details_object.group_name
		comments := details_object.comments

		padded_shortcut_keys := SubStr(shortcut_keys . "                  ", 1, 18)
		padded_group_name := group_name
		If (details_object.is_ahk)
		  padded_group_name = %padded_group_name% (AHK)
	  padded_group_name := SubStr(padded_group_name . "                   ", 1, 19)
		
		If (last_group != "" And last_group != group_name)
		  output = %output%;`r`n
 		output = %output%; %padded_shortcut_keys% %padded_group_name% %comments%`r`n

		last_group := group_name
	}

	Return output
}


;---------------------------------------------------------------------------------------------------------------------
; Build the new script by replacing the "Shortcuts" documentation part of the script with our newly generated
; documentation
;---------------------------------------------------------------------------------------------------------------------
BuildNewScript(old_script, new_hotkey_descriptions) {
	title_dashes := Replicate("-", 30)
	end_of_comments_dashes := Replicate("=", 120)
	documentation_header := "; Hotkeys - Auto-Generated`r`n; " . title_dashes . "`r`n"
	documentation_footer := ";" . end_of_comments_dashes

  old_documentation_regex := "s)" . documentation_header . ";..*?" . documentation_footer
	new_documentation := documentation_header . new_hotkey_descriptions . documentation_footer

	new_script := RegExReplace(old_script, old_documentation_regex, new_documentation)

	Return new_script
}


;---------------------------------------------------------------------------------------------------------------------
; Backup the script
;---------------------------------------------------------------------------------------------------------------------
BackupScript(script_filename) {
	source_filename = %script_filename%
	FormatTime, CurrentDateTime,, yyyy-MM-ddThh-mm-ss
	target_filename = %source_filename%.%CurrentDateTime%.ahk
  FileCopy, %source_filename%, %target_filename%
}


;---------------------------------------------------------------------------------------------------------------------
; Replicate a string 
; Code by SKAN / CD: 01-July-2017 | goo.gl/U84K7J
;---------------------------------------------------------------------------------------------------------------------
Replicate(str, count) { 
  Return StrReplace( Format( "{:0" count "}", "" ), 0, str )
}


;---------------------------------------------------------------------------------------------------------------------
; Sort a simple array of strings
; Code from https://autohotkey.com/board/topic/93570-sortarray/
;---------------------------------------------------------------------------------------------------------------------
SortArray(arr) {
	If	!IsObject(arr)
		Return	0
	new :=	[]
	For each, item in arr
		list .=	item "`n"
	list :=	Trim(list,"`n")
	Sort, list, %options%
	Loop, parse, list, `n, `r
		new.Insert(A_LoopField)
	Return new
}