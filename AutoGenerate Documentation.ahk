;---------------------------------------------------------------------------------------------------------------------
; Auto generate documentation
; Read this script and build a list of shortcut keys
; replace the existing documentation in this script
; make a backup before overwriting
;---------------------------------------------------------------------------------------------------------------------
AutoGenerateDocumentation(script_filename) 
{
  Sleep, 1000     ; Give VS Code time to save the file before we start
	
	shortcut_details := ParseOutShortcuts(script_filename)
	shortcut_array_keys := BuildArrayKeysForSorting(shortcut_details)
	new_shortcut_key_descriptions := BuildNewShortcutKeyDescriptions(shortcut_array_keys, shortcut_details)

	FileRead, old_script, %script_filename%
	new_script := BuildNewScript(old_script, new_shortcut_key_descriptions)

	If (new_script != old_script)
	{
	  BackupScript(script_filename)

		FileDelete, %script_filename%
		FileAppend, %new_script%, %script_filename%

		MsgBox, Done regenerating shortcut documentation.
	}

	Return
}


ParseOutShortcuts(script_filename) 
{
	shortcut_details := []
	
	Loop
	{
    FileReadLine, line, %script_filename%, %A_Index%
    if ErrorLevel
      break
		; When search for lines in this file, have to explicitly exclude the next line
		If (RegExMatch(line, ".*;?.*::.*;.*[\|].*[\|]") And InStr(line, "RegExMatch") == 0)
		{
			;MsgBox, 4, , Line #%A_Index% MATCHES: %line%. Continue?
    	;IfMsgBox, No
      ;  break
			current_shortcut_details := {array_key: "", raw_text: "", shortcut_keys: "", group_name: "", is_ahk: "", comments: ""}

			; Parse out shortcut keys, the group name, and the comments
			; The "extra" assignment to variables trims leading and trailing spaces
			; TODO: Exclude commented code: If line starts with ; and is_ahk then is commented code and skip it
			RegExMatch(line, "[;]?(.*)`:`:.*\;(.*?)\|(.*)\|(.*)", info)
			shortcut_keys = %info1%
			group_name = %info2%
			is_ahk = %info3%
			comments = %info4%

      ; Save the details of this shortcut key
			current_shortcut_details.shortcut_keys := shortcut_keys
			current_shortcut_details.group_name := group_name
			current_shortcut_details.is_ahk := is_ahk
			current_shortcut_details.comments := comments
			shortcut_details.Push(current_shortcut_details)

			current_shortcut_details := ""  ; Release the object
		}
	}

	Return shortcut_details
}


BuildArrayKeysForSorting(shortcut_details) 
{
	shortcut_array_keys := []
	
	for index, element in shortcut_details
	{
		; For sorting, want keys to look like this for nice sorting purposes, keeping all varieties of
		; shortcut keys for a single letter together
		;   Windows|j|#^j|JIRA
		;   Windows|j|#j|JIRA
		shortcut_keys_all := element.shortcut_keys
		shortcut_keys_stripped := RegExReplace(shortcut_keys_all, "[#^+!]")
		group_name := element.group_name
		array_key = %group_name%|%shortcut_keys_stripped%|%shortcut_keys_all%|%index%
		;MsgBox, 4, , Line #%index% KEY = %array_key%. Continue?
		;IfMsgBox, No
		;  break
		shortcut_array_keys.Push(array_key)
	}

	Return shortcut_array_keys
}


BuildNewShortcutKeyDescriptions(shortcut_array_keys, shortcut_details) {
	; Sort the array of keys in the order we want
  shortcut_array_keys := SortArray(shortcut_array_keys)

	; Build the output. Use shortcut_array_keys to get shortcut keys in the desired order.
	output := ""
	last_group := ""
	for index, element in shortcut_array_keys
	{
		details_index := StrSplit(element, "|")[4]
    details_object := shortcut_details[details_index]

		shortcut_keys := details_object.shortcut_keys
		group_name := details_object.group_name
		comments := details_object.comments

		padded_shortcut_keys := SubStr(shortcut_keys . "               ", 1, 15)
		padded_group_name := group_name
		If (details_object.is_ahk)
		  padded_group_name = %padded_group_name% (AHK)
	  padded_group_name := SubStr(padded_group_name . "                   ", 1, 19)
		
		If (last_group != "" And last_group != group_name)
		  output = %output%;`r`n
 		output = %output%; %padded_shortcut_keys% %padded_group_name% %comments%`r`n

		last_group := group_name
	}

	Return output
}


BuildNewScript(old_script, shortcut_key_descriptions) {
	; Replace the "Shortcuts" documentation with our newly generated documentation
	title_dashes := Replicate("-", 30)
	end_of_comments_dashes := Replicate("=", 120)
	documentation_header := "; Shortcuts - Auto-Generated`r`n; " . title_dashes . "`r`n"
	documentation_footer := ";" . end_of_comments_dashes

	new_documentation := documentation_header . shortcut_key_descriptions . documentation_footer

  old_documentation_regex := "s)" . documentation_header . ";..*?" . documentation_footer

	new_script := RegExReplace(old_script, old_documentation_regex, new_documentation)

	Return new_script
}


BackupScript(script_filename) {
 	; Backup our script
	source_filename = %script_filename%
	FormatTime, CurrentDateTime,, yyyy-MM-ddThh-mm-ss
	target_filename = %source_filename%.%CurrentDateTime%.ahk
  FileCopy, %source_filename%, %target_filename%
}


;---------------------------------------------------------------------------------------------------------------------
; Replicate a string 
; Code by SKAN / CD: 01-July-2017 | goo.gl/U84K7J
;---------------------------------------------------------------------------------------------------------------------
Replicate(str, count) { 
  Return StrReplace( Format( "{:0" count "}", "" ), 0, str )
}


;---------------------------------------------------------------------------------------------------------------------
; Sort a simple array of strings
; Code from https://autohotkey.com/board/topic/93570-sortarray/
;---------------------------------------------------------------------------------------------------------------------
SortArray(arr) {
	If	!IsObject(arr)
		Return	0
	new :=	[]
	For each, item in arr
		list .=	item "`n"
	list :=	Trim(list,"`n")
	Sort, list, %options%
	Loop, parse, list, `n, `r
		new.Insert(A_LoopField)
	Return new
}